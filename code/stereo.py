import random
import sys
import math
from PIL import Image
from PIL import ImageChops
import numpy as np

import time

# Run the syntax below in terminal for each picture:
#   python3 stereo.py Aloe/view1.png Aloe/view5.png Aloe/gt.png
#   python3 stereo.py Baby1/view1.png Baby1/view5.png Baby1/gt.png
#   python3 stereo.py Flowerpots/view1.png Flowerpots/view5.png Flowerpots/gt.png


MAX_DISPARITY = 65

# This function should compute the function D() in the assignment
def disparity_costs(img1, img2, size, alpha=0.53):
    """
    Calculate disparity cost between two images using scanline method.
    Description
    ----------------
    Disparity cost uses the truncanted quadratic models which is the squared difference between two window (left and right image) with
    the maximum cost value is limitized by alpha value. The left window is a basis and the right window will be slided
    horizantally in the left direction of the right image where each slide, the disparity cost is calculated.
    The total iteration or slide of right window is controlled by MAX_DISPARITY. The disparity costs will be stored
    in the 3D array with size of (H,W,D) where H is image height, W is image width, and D is MAX_DISPARITY.
    ----------------
    :param image1 : left image
    :param image2 : right image
    :param size : squared-shaped block matching window size (should be an odd number)
    :param alpha : float number [0,1] as a regulation the maximum cost value
    :return:
    """
    # Add padding to the normalized input image. The padding size is adjusted based on image window size and MAX_DISPARITY
    pad_size = int((size-1)/2)

    img1_padded = np.array(np.pad(img1, pad_width = (pad_size, pad_size), mode = 'reflect'))/255
    img2_padded = np.array(np.pad(img2, pad_width = (pad_size, pad_size), mode = 'reflect'))/255

    # Cost map template with the same size of image and depth of image width
    result = np.zeros((img1.shape[0], img1.shape[1],  MAX_DISPARITY * 2 - 1))


    # Block based matching
    for i in range(pad_size,img1_padded.shape[0]-pad_size):
        for j in range(pad_size,img1_padded.shape[1]-pad_size):
            # Subsampling image into small window
            window_pad_size = int((size-1)/2)

            # Window's bounding box coordinate
            y1 = i-pad_size
            y2 = i+pad_size+1
            x1 = j-pad_size
            x2 = j+pad_size+1

            # Subsampling left image
            left_window = img1_padded[y1:y2,x1:x2]

            # Left direction
            for k in range(MAX_DISPARITY):
                # Cost function in left direction
                if x1-k >= 0:
                    right_window = img2_padded[y1:y2, x1-k:x2-k]
                    cost = min(alpha,np.sum((left_window-right_window)**2))
                else:
                    cost = 100000  # Set the cost to be abundantly larged so it would not be picked during minimization process
                # Update cost map
                result[y1, x1, MAX_DISPARITY - 1 - k] = cost

                # Cost function in right direction
                if k > 0:
                    if x2 + k <= img1_padded.shape[1]:
                        right_window = img2_padded[y1:y2, x1 + k:x2 + k]
                        cost = np.sum((left_window - right_window) ** 2)
                    else:
                        cost = 100000  # Set the cost to be very larged so it would not be picked during minimization
                    # Update cost map
                    result[y1, x1, MAX_DISPARITY - 1 + k] = cost

    norm_result = result/np.sum(result,axis=2)[:,:,np.newaxis]
    return norm_result

# This function finds the minimum cost at each pixel
def naive_stereo(disp_costs):
    """
    Naive stereo algorithm to find the disparity with minimum cost.

    Description
    ----------------
    Replacing the pixels value which < 127.5 as 0 (black pixels), otherwise as 255 (white pixels)
    Parameters
    ----------------
    :param disp_costs : cost map (x,y,z) generated by disparity cost function
    :return:
    """
    # Finding the minimum costs
    min_cost = np.amin(disp_costs,axis=2)
    min_cost_index = np.abs(np.argmin(disp_costs,axis=2) - (MAX_DISPARITY - 1))

    return min_cost_index

def transition_cost(disp_costs, alpha = 300):
    """
    Calculating the transition costs given the all possible labels created in disparity_costs().

    Description
    ----------------
    Cost is calculated using truncated squared function where the maxiumum value is adjusted by alpha value.
    ----------------
    :param disp_costs : cost map (x,y,z) generated by disparity cost function
    :param alpha : float value that determined the max value of transition cost
    :return: matrix with shape (H,W,D,C) where D is the number of possible label and C is the combination of transition
    between labels (D^2)
    """
    v = np.zeros((disp_costs.shape[2], disp_costs.shape[2]))
    for label in range(disp_costs.shape[2]):
        for d in range(disp_costs.shape[2]):
            # Transition cost using truncated square function
            v[label,d] = min(alpha, (np.abs(label - (MAX_DISPARITY - 1)) - np.abs(d - (MAX_DISPARITY - 1))) ** 2)
    v= v/(np.sum(v,axis=1)[np.newaxis,:])
    return v

def message_passing(disp_costs, v_costs, messages, iter, beta=1, direction='right'):
    """
    Producing message passing sequences (left, right, up, or down).

    Description
    ----------------
    Accumulating the information from disparity costs, transition costs, and messages sent to the current node at timestamp
    t-1.
    ----------------
    :param disp_costs : cost map (x,y,z) generated by disparity cost function
    :param v_costs : transition costs value
    :param messages : genereated messages value from the previous iteration
    :param beta : real value that determined the contribution of transition costs.
    :param: direction where the message is passed to.
    :return: matrix with shape (H,W,D). H is the height of image, W is the width of image, and D is the number of possible
    disparity label.
    """
    for label in range(disp_costs.shape[2]):
        v_i = v_costs[label][np.newaxis,np.newaxis,:]
        shift_m_right = np.roll(messages, 1, axis=1)
        shift_m_right[:, 0, :] = 0
        shift_m_left = np.roll(messages, -1, axis=1)
        shift_m_left[:, -1, :] = 0
        shift_m_up = np.roll(messages, -1, axis=0)
        shift_m_up[-1, :, :] = 0
        shift_m_down = np.roll(messages, 1, axis=0)
        shift_m_down[0, :, :] = 0
        if direction == 'right':
            cost = disp_costs + beta * v_i + shift_m_right + shift_m_down + shift_m_up
        elif direction == 'left':
            cost = disp_costs + beta * v_i + shift_m_left + shift_m_down + shift_m_up
        elif direction == 'up':
            cost = disp_costs + beta * v_i + shift_m_left + shift_m_right + shift_m_up
        elif direction == 'down':
            cost = disp_costs + beta * v_i + shift_m_left + shift_m_down + shift_m_right
        m_t = np.amin(cost, axis=2)
        messages[:, :, label] = m_t
    sum_m_all_label = np.sum(messages,axis=2)[:,:,np.newaxis]
    # Replacing sum value with 1 for pixels that do not have message cost in all labels
    sum_m_all_label[sum_m_all_label == 0] = 1
    messages = messages/sum_m_all_label
    return messages

def mrf_stereo(disp_costs, v_costs, iter, beta=1):
    """
    Predicting the best disparity label for each pixels that has the minimum cost value.

    Description
    ----------------
    On each label, the disparity cost of a pixels and the messages gathered from the neighbors are accumulated.
    After collected the cost from all the labels, the algorithm find the best label that produces the minimum cost.
    ----------------
    :param disp_costs : cost map (x,y,z) generated by disparity cost function.
    :param v_costs : transition costs value.
    :param iter : maximum iteration to be executed.
    :param beta :real value that determined the contribution of transition costs for message_passing().
    :return: matrix with shape (H,W) that contains the best disparity label in each pixel.
    """
    # Message initialization at t=0
    messages = np.zeros((disp_costs.shape[0], disp_costs.shape[1], disp_costs.shape[2]))
    total_m = []
    for t in range(iter):
        for dir in ['right','left','up','down']:
            messages = message_passing(disp_costs, v_costs, messages, iter, beta, direction=dir)
        total_m.append(np.sum(messages))
        if t < 1:
            delta = 1000
        else:
            delta = total_m[-1] - total_m[-2]
        if delta < 0.01:
            break
    shift_m_right = np.roll(messages, 1, axis=1)
    shift_m_right[:, 0, :] = 0
    shift_m_left = np.roll(messages, -1, axis=1)
    shift_m_left[:, -1, :] = 0
    shift_m_up = np.roll(messages, -1, axis=0)
    shift_m_up[-1, :, :] = 0
    shift_m_down = np.roll(messages, 1, axis=0)
    shift_m_down[0, :, :] = 0

    result = disp_costs + shift_m_right + shift_m_left + shift_m_up + shift_m_down
    return np.abs(np.argmin(result,axis=2) - (MAX_DISPARITY - 1))

def stereoscopic_image(img1,img2):
    """
    Creating the red-cyan 3D illusion image.

    Description
    ----------------
    The key idea is merging two images. The left image is converted into red color while
    the right image is in cyan color (combination of green and blue).
    ----------------
    :param img1 : left image
    :param img2 : right image
    :return : new image array
    """
    left_img = Image.open(img1)
    right_img = Image.open(img2)

    R_img = right_img.getchannel('R')
    G_img = left_img.getchannel('G')
    B_img = left_img.getchannel('B')

    # Use an offset to regualate the shift distance between two image
    # This will determine how deep or close the 3D image will look.
    R_img = ImageChops.offset(R_img, 25, 0)

    new_img = Image.merge('RGB', [R_img, G_img, B_img])
    new_img.show()

    return new_img

                      
if __name__ == "__main__":

    start_time = time.time()

    if len(sys.argv) != 3 and len(sys.argv) != 4:
        raise Exception("usage: " + sys.argv[0] + " image_file1 image_file2 [gt_file]")
    input_filename1, input_filename2 = sys.argv[1], sys.argv[2]

    image1 = np.asarray(Image.open(input_filename1), dtype=np.float64)
    image2 = np.asarray(Image.open(input_filename2), dtype=np.float64)

    gt = None
    if len(sys.argv) == 4:
        gt = np.array(Image.open(sys.argv[3]))[:,:,0]

    # compute the disparity costs (function D_2())
    disp_costs = disparity_costs(image1, image2, size=5, alpha=0.53)

    # Naive stereo algorithm
    disp1 = naive_stereo(disp_costs)
    disp1_img = (disp1/np.amax(disp1)*255)
    Image.fromarray(disp1_img.astype(np.uint8)).save("output-naive.png")
        
    # Stereo MRF algorithm
    v_cost = transition_cost(disp_costs,alpha=100)
    disp3 = mrf_stereo(disp_costs, v_cost,iter=5, beta=1)
    disp3_img = (disp3 / np.amax(disp3) * 255)
    Image.fromarray(disp3_img.astype(np.uint8)).save("output-mrf.png")

    # Measure error with respect to ground truth, if we have it...
    if gt is not None:
        err = np.sum((disp1_img- gt)**2)/gt.shape[0]/gt.shape[1]
        print("Naive stereo technique mean error = " + str(err))

        err = np.sum((disp3_img- gt)**2)/gt.shape[0]/gt.shape[1]
        print("MRF stereo technique mean error = " + str(err))

    # Generating stereoscopic image
    stereoscopic_image(input_filename1,input_filename2).save('3D-image.png')

    print("--- Running time",(time.time() - start_time),'seconds ---')


                                                                                                                                                                                                           
